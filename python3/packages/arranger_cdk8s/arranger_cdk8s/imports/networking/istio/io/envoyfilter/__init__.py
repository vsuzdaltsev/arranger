import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from ._jsii import *

import cdk8s
import constructs


class EnvoyFilter(
    cdk8s.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="networkingistioioenvoyfilter.EnvoyFilter",
):
    """
    :schema: EnvoyFilter
    """

    def __init__(
        self,
        scope: constructs.Construct,
        name: builtins.str,
        *,
        spec: typing.Optional["EnvoyFilterSpec"] = None,
    ) -> None:
        """Defines a "EnvoyFilter" API object.

        :param scope: the scope in which to define this object.
        :param name: a scope-local name for the object.
        :param spec: Customizing Envoy configuration generated by Istio. See more details at: https://istio.io/docs/reference/config/networking/envoy-filter.html
        """
        options = EnvoyFilterOptions(spec=spec)

        jsii.create(EnvoyFilter, self, [scope, name, options])


@jsii.data_type(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterOptions",
    jsii_struct_bases=[],
    name_mapping={"spec": "spec"},
)
class EnvoyFilterOptions:
    def __init__(self, *, spec: typing.Optional["EnvoyFilterSpec"] = None) -> None:
        """
        :param spec: Customizing Envoy configuration generated by Istio. See more details at: https://istio.io/docs/reference/config/networking/envoy-filter.html

        :schema: EnvoyFilter
        """
        if isinstance(spec, dict):
            spec = EnvoyFilterSpec(**spec)
        self._values: typing.Dict[str, typing.Any] = {}
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def spec(self) -> typing.Optional["EnvoyFilterSpec"]:
        """Customizing Envoy configuration generated by Istio.

        See more details at: https://istio.io/docs/reference/config/networking/envoy-filter.html

        :schema: EnvoyFilter#spec
        """
        result = self._values.get("spec")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EnvoyFilterOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpec",
    jsii_struct_bases=[],
    name_mapping={
        "config_patches": "configPatches",
        "workload_selector": "workloadSelector",
    },
)
class EnvoyFilterSpec:
    def __init__(
        self,
        *,
        config_patches: typing.Optional[typing.List["EnvoyFilterSpecConfigPatches"]] = None,
        workload_selector: typing.Optional["EnvoyFilterSpecWorkloadSelector"] = None,
    ) -> None:
        """Customizing Envoy configuration generated by Istio.

        See more details at: https://istio.io/docs/reference/config/networking/envoy-filter.html

        :param config_patches: One or more patches with match conditions.
        :param workload_selector: 

        :schema: EnvoyFilterSpec
        """
        if isinstance(workload_selector, dict):
            workload_selector = EnvoyFilterSpecWorkloadSelector(**workload_selector)
        self._values: typing.Dict[str, typing.Any] = {}
        if config_patches is not None:
            self._values["config_patches"] = config_patches
        if workload_selector is not None:
            self._values["workload_selector"] = workload_selector

    @builtins.property
    def config_patches(
        self,
    ) -> typing.Optional[typing.List["EnvoyFilterSpecConfigPatches"]]:
        """One or more patches with match conditions.

        :schema: EnvoyFilterSpec#configPatches
        """
        result = self._values.get("config_patches")
        return result

    @builtins.property
    def workload_selector(self) -> typing.Optional["EnvoyFilterSpecWorkloadSelector"]:
        """
        :schema: EnvoyFilterSpec#workloadSelector
        """
        result = self._values.get("workload_selector")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EnvoyFilterSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecConfigPatches",
    jsii_struct_bases=[],
    name_mapping={"apply_to": "applyTo", "match": "match", "patch": "patch"},
)
class EnvoyFilterSpecConfigPatches:
    def __init__(
        self,
        *,
        apply_to: typing.Optional["EnvoyFilterSpecConfigPatchesApplyTo"] = None,
        match: typing.Optional["EnvoyFilterSpecConfigPatchesMatch"] = None,
        patch: typing.Optional["EnvoyFilterSpecConfigPatchesPatch"] = None,
    ) -> None:
        """
        :param apply_to: 
        :param match: Match on listener/route configuration/cluster.
        :param patch: The patch to apply along with the operation.

        :schema: EnvoyFilterSpecConfigPatches
        """
        if isinstance(match, dict):
            match = EnvoyFilterSpecConfigPatchesMatch(**match)
        if isinstance(patch, dict):
            patch = EnvoyFilterSpecConfigPatchesPatch(**patch)
        self._values: typing.Dict[str, typing.Any] = {}
        if apply_to is not None:
            self._values["apply_to"] = apply_to
        if match is not None:
            self._values["match"] = match
        if patch is not None:
            self._values["patch"] = patch

    @builtins.property
    def apply_to(self) -> typing.Optional["EnvoyFilterSpecConfigPatchesApplyTo"]:
        """
        :schema: EnvoyFilterSpecConfigPatches#applyTo
        """
        result = self._values.get("apply_to")
        return result

    @builtins.property
    def match(self) -> typing.Optional["EnvoyFilterSpecConfigPatchesMatch"]:
        """Match on listener/route configuration/cluster.

        :schema: EnvoyFilterSpecConfigPatches#match
        """
        result = self._values.get("match")
        return result

    @builtins.property
    def patch(self) -> typing.Optional["EnvoyFilterSpecConfigPatchesPatch"]:
        """The patch to apply along with the operation.

        :schema: EnvoyFilterSpecConfigPatches#patch
        """
        result = self._values.get("patch")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EnvoyFilterSpecConfigPatches(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecConfigPatchesApplyTo"
)
class EnvoyFilterSpecConfigPatchesApplyTo(enum.Enum):
    """
    :schema: EnvoyFilterSpecConfigPatchesApplyTo
    """

    INVALID = "INVALID"
    """INVALID."""
    LISTENER = "LISTENER"
    """LISTENER."""
    FILTER_CHAIN = "FILTER_CHAIN"
    """FILTER_CHAIN."""
    NETWORK_FILTER = "NETWORK_FILTER"
    """NETWORK_FILTER."""
    HTTP_FILTER = "HTTP_FILTER"
    """HTTP_FILTER."""
    ROUTE_CONFIGURATION = "ROUTE_CONFIGURATION"
    """ROUTE_CONFIGURATION."""
    VIRTUAL_HOST = "VIRTUAL_HOST"
    """VIRTUAL_HOST."""
    HTTP_ROUTE = "HTTP_ROUTE"
    """HTTP_ROUTE."""
    CLUSTER = "CLUSTER"
    """CLUSTER."""
    EXTENSION_CONFIG = "EXTENSION_CONFIG"
    """EXTENSION_CONFIG."""


@jsii.data_type(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecConfigPatchesMatch",
    jsii_struct_bases=[],
    name_mapping={
        "cluster": "cluster",
        "context": "context",
        "listener": "listener",
        "proxy": "proxy",
        "route_configuration": "routeConfiguration",
    },
)
class EnvoyFilterSpecConfigPatchesMatch:
    def __init__(
        self,
        *,
        cluster: typing.Optional["EnvoyFilterSpecConfigPatchesMatchCluster"] = None,
        context: typing.Optional["EnvoyFilterSpecConfigPatchesMatchContext"] = None,
        listener: typing.Optional["EnvoyFilterSpecConfigPatchesMatchListener"] = None,
        proxy: typing.Optional["EnvoyFilterSpecConfigPatchesMatchProxy"] = None,
        route_configuration: typing.Optional["EnvoyFilterSpecConfigPatchesMatchRouteConfiguration"] = None,
    ) -> None:
        """Match on listener/route configuration/cluster.

        :param cluster: Match on envoy cluster attributes.
        :param context: The specific config generation context to match on.
        :param listener: Match on envoy listener attributes.
        :param proxy: Match on properties associated with a proxy.
        :param route_configuration: Match on envoy HTTP route configuration attributes.

        :schema: EnvoyFilterSpecConfigPatchesMatch
        """
        if isinstance(cluster, dict):
            cluster = EnvoyFilterSpecConfigPatchesMatchCluster(**cluster)
        if isinstance(listener, dict):
            listener = EnvoyFilterSpecConfigPatchesMatchListener(**listener)
        if isinstance(proxy, dict):
            proxy = EnvoyFilterSpecConfigPatchesMatchProxy(**proxy)
        if isinstance(route_configuration, dict):
            route_configuration = EnvoyFilterSpecConfigPatchesMatchRouteConfiguration(**route_configuration)
        self._values: typing.Dict[str, typing.Any] = {}
        if cluster is not None:
            self._values["cluster"] = cluster
        if context is not None:
            self._values["context"] = context
        if listener is not None:
            self._values["listener"] = listener
        if proxy is not None:
            self._values["proxy"] = proxy
        if route_configuration is not None:
            self._values["route_configuration"] = route_configuration

    @builtins.property
    def cluster(self) -> typing.Optional["EnvoyFilterSpecConfigPatchesMatchCluster"]:
        """Match on envoy cluster attributes.

        :schema: EnvoyFilterSpecConfigPatchesMatch#cluster
        """
        result = self._values.get("cluster")
        return result

    @builtins.property
    def context(self) -> typing.Optional["EnvoyFilterSpecConfigPatchesMatchContext"]:
        """The specific config generation context to match on.

        :schema: EnvoyFilterSpecConfigPatchesMatch#context
        """
        result = self._values.get("context")
        return result

    @builtins.property
    def listener(self) -> typing.Optional["EnvoyFilterSpecConfigPatchesMatchListener"]:
        """Match on envoy listener attributes.

        :schema: EnvoyFilterSpecConfigPatchesMatch#listener
        """
        result = self._values.get("listener")
        return result

    @builtins.property
    def proxy(self) -> typing.Optional["EnvoyFilterSpecConfigPatchesMatchProxy"]:
        """Match on properties associated with a proxy.

        :schema: EnvoyFilterSpecConfigPatchesMatch#proxy
        """
        result = self._values.get("proxy")
        return result

    @builtins.property
    def route_configuration(
        self,
    ) -> typing.Optional["EnvoyFilterSpecConfigPatchesMatchRouteConfiguration"]:
        """Match on envoy HTTP route configuration attributes.

        :schema: EnvoyFilterSpecConfigPatchesMatch#routeConfiguration
        """
        result = self._values.get("route_configuration")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EnvoyFilterSpecConfigPatchesMatch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecConfigPatchesMatchCluster",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "port_number": "portNumber",
        "service": "service",
        "subset": "subset",
    },
)
class EnvoyFilterSpecConfigPatchesMatchCluster:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        port_number: typing.Optional[jsii.Number] = None,
        service: typing.Optional[builtins.str] = None,
        subset: typing.Optional[builtins.str] = None,
    ) -> None:
        """Match on envoy cluster attributes.

        :param name: The exact name of the cluster to match.
        :param port_number: The service port for which this cluster was generated.
        :param service: The fully qualified service name for this cluster.
        :param subset: The subset associated with the service.

        :schema: EnvoyFilterSpecConfigPatchesMatchCluster
        """
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if port_number is not None:
            self._values["port_number"] = port_number
        if service is not None:
            self._values["service"] = service
        if subset is not None:
            self._values["subset"] = subset

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """The exact name of the cluster to match.

        :schema: EnvoyFilterSpecConfigPatchesMatchCluster#name
        """
        result = self._values.get("name")
        return result

    @builtins.property
    def port_number(self) -> typing.Optional[jsii.Number]:
        """The service port for which this cluster was generated.

        :schema: EnvoyFilterSpecConfigPatchesMatchCluster#portNumber
        """
        result = self._values.get("port_number")
        return result

    @builtins.property
    def service(self) -> typing.Optional[builtins.str]:
        """The fully qualified service name for this cluster.

        :schema: EnvoyFilterSpecConfigPatchesMatchCluster#service
        """
        result = self._values.get("service")
        return result

    @builtins.property
    def subset(self) -> typing.Optional[builtins.str]:
        """The subset associated with the service.

        :schema: EnvoyFilterSpecConfigPatchesMatchCluster#subset
        """
        result = self._values.get("subset")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EnvoyFilterSpecConfigPatchesMatchCluster(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecConfigPatchesMatchContext"
)
class EnvoyFilterSpecConfigPatchesMatchContext(enum.Enum):
    """The specific config generation context to match on.

    :schema: EnvoyFilterSpecConfigPatchesMatchContext
    """

    ANY = "ANY"
    """ANY."""
    SIDECAR_INBOUND = "SIDECAR_INBOUND"
    """SIDECAR_INBOUND."""
    SIDECAR_OUTBOUND = "SIDECAR_OUTBOUND"
    """SIDECAR_OUTBOUND."""
    GATEWAY = "GATEWAY"
    """GATEWAY."""


@jsii.data_type(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecConfigPatchesMatchListener",
    jsii_struct_bases=[],
    name_mapping={
        "filter_chain": "filterChain",
        "name": "name",
        "port_name": "portName",
        "port_number": "portNumber",
    },
)
class EnvoyFilterSpecConfigPatchesMatchListener:
    def __init__(
        self,
        *,
        filter_chain: typing.Optional["EnvoyFilterSpecConfigPatchesMatchListenerFilterChain"] = None,
        name: typing.Optional[builtins.str] = None,
        port_name: typing.Optional[builtins.str] = None,
        port_number: typing.Optional[jsii.Number] = None,
    ) -> None:
        """Match on envoy listener attributes.

        :param filter_chain: Match a specific filter chain in a listener.
        :param name: Match a specific listener by its name.
        :param port_name: 
        :param port_number: 

        :schema: EnvoyFilterSpecConfigPatchesMatchListener
        """
        if isinstance(filter_chain, dict):
            filter_chain = EnvoyFilterSpecConfigPatchesMatchListenerFilterChain(**filter_chain)
        self._values: typing.Dict[str, typing.Any] = {}
        if filter_chain is not None:
            self._values["filter_chain"] = filter_chain
        if name is not None:
            self._values["name"] = name
        if port_name is not None:
            self._values["port_name"] = port_name
        if port_number is not None:
            self._values["port_number"] = port_number

    @builtins.property
    def filter_chain(
        self,
    ) -> typing.Optional["EnvoyFilterSpecConfigPatchesMatchListenerFilterChain"]:
        """Match a specific filter chain in a listener.

        :schema: EnvoyFilterSpecConfigPatchesMatchListener#filterChain
        """
        result = self._values.get("filter_chain")
        return result

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """Match a specific listener by its name.

        :schema: EnvoyFilterSpecConfigPatchesMatchListener#name
        """
        result = self._values.get("name")
        return result

    @builtins.property
    def port_name(self) -> typing.Optional[builtins.str]:
        """
        :schema: EnvoyFilterSpecConfigPatchesMatchListener#portName
        """
        result = self._values.get("port_name")
        return result

    @builtins.property
    def port_number(self) -> typing.Optional[jsii.Number]:
        """
        :schema: EnvoyFilterSpecConfigPatchesMatchListener#portNumber
        """
        result = self._values.get("port_number")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EnvoyFilterSpecConfigPatchesMatchListener(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecConfigPatchesMatchListenerFilterChain",
    jsii_struct_bases=[],
    name_mapping={
        "application_protocols": "applicationProtocols",
        "destination_port": "destinationPort",
        "filter": "filter",
        "name": "name",
        "sni": "sni",
        "transport_protocol": "transportProtocol",
    },
)
class EnvoyFilterSpecConfigPatchesMatchListenerFilterChain:
    def __init__(
        self,
        *,
        application_protocols: typing.Optional[builtins.str] = None,
        destination_port: typing.Optional[jsii.Number] = None,
        filter: typing.Optional["EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter"] = None,
        name: typing.Optional[builtins.str] = None,
        sni: typing.Optional[builtins.str] = None,
        transport_protocol: typing.Optional[builtins.str] = None,
    ) -> None:
        """Match a specific filter chain in a listener.

        :param application_protocols: Applies only to sidecars.
        :param destination_port: The destination_port value used by a filter chain's match condition.
        :param filter: The name of a specific filter to apply the patch to.
        :param name: The name assigned to the filter chain.
        :param sni: The SNI value used by a filter chain's match condition.
        :param transport_protocol: Applies only to ``SIDECAR_INBOUND`` context.

        :schema: EnvoyFilterSpecConfigPatchesMatchListenerFilterChain
        """
        if isinstance(filter, dict):
            filter = EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter(**filter)
        self._values: typing.Dict[str, typing.Any] = {}
        if application_protocols is not None:
            self._values["application_protocols"] = application_protocols
        if destination_port is not None:
            self._values["destination_port"] = destination_port
        if filter is not None:
            self._values["filter"] = filter
        if name is not None:
            self._values["name"] = name
        if sni is not None:
            self._values["sni"] = sni
        if transport_protocol is not None:
            self._values["transport_protocol"] = transport_protocol

    @builtins.property
    def application_protocols(self) -> typing.Optional[builtins.str]:
        """Applies only to sidecars.

        :schema: EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#applicationProtocols
        """
        result = self._values.get("application_protocols")
        return result

    @builtins.property
    def destination_port(self) -> typing.Optional[jsii.Number]:
        """The destination_port value used by a filter chain's match condition.

        :schema: EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#destinationPort
        """
        result = self._values.get("destination_port")
        return result

    @builtins.property
    def filter(
        self,
    ) -> typing.Optional["EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter"]:
        """The name of a specific filter to apply the patch to.

        :schema: EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#filter
        """
        result = self._values.get("filter")
        return result

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """The name assigned to the filter chain.

        :schema: EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#name
        """
        result = self._values.get("name")
        return result

    @builtins.property
    def sni(self) -> typing.Optional[builtins.str]:
        """The SNI value used by a filter chain's match condition.

        :schema: EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#sni
        """
        result = self._values.get("sni")
        return result

    @builtins.property
    def transport_protocol(self) -> typing.Optional[builtins.str]:
        """Applies only to ``SIDECAR_INBOUND`` context.

        :schema: EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#transportProtocol
        """
        result = self._values.get("transport_protocol")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EnvoyFilterSpecConfigPatchesMatchListenerFilterChain(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "sub_filter": "subFilter"},
)
class EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        sub_filter: typing.Optional["EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter"] = None,
    ) -> None:
        """The name of a specific filter to apply the patch to.

        :param name: The filter name to match on.
        :param sub_filter: 

        :schema: EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter
        """
        if isinstance(sub_filter, dict):
            sub_filter = EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter(**sub_filter)
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if sub_filter is not None:
            self._values["sub_filter"] = sub_filter

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """The filter name to match on.

        :schema: EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter#name
        """
        result = self._values.get("name")
        return result

    @builtins.property
    def sub_filter(
        self,
    ) -> typing.Optional["EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter"]:
        """
        :schema: EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter#subFilter
        """
        result = self._values.get("sub_filter")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        """
        :param name: The filter name to match on.

        :schema: EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter
        """
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """The filter name to match on.

        :schema: EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter#name
        """
        result = self._values.get("name")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecConfigPatchesMatchProxy",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "proxy_version": "proxyVersion"},
)
class EnvoyFilterSpecConfigPatchesMatchProxy:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        proxy_version: typing.Optional[builtins.str] = None,
    ) -> None:
        """Match on properties associated with a proxy.

        :param metadata: 
        :param proxy_version: 

        :schema: EnvoyFilterSpecConfigPatchesMatchProxy
        """
        self._values: typing.Dict[str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if proxy_version is not None:
            self._values["proxy_version"] = proxy_version

    @builtins.property
    def metadata(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """
        :schema: EnvoyFilterSpecConfigPatchesMatchProxy#metadata
        """
        result = self._values.get("metadata")
        return result

    @builtins.property
    def proxy_version(self) -> typing.Optional[builtins.str]:
        """
        :schema: EnvoyFilterSpecConfigPatchesMatchProxy#proxyVersion
        """
        result = self._values.get("proxy_version")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EnvoyFilterSpecConfigPatchesMatchProxy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecConfigPatchesMatchRouteConfiguration",
    jsii_struct_bases=[],
    name_mapping={
        "gateway": "gateway",
        "name": "name",
        "port_name": "portName",
        "port_number": "portNumber",
        "vhost": "vhost",
    },
)
class EnvoyFilterSpecConfigPatchesMatchRouteConfiguration:
    def __init__(
        self,
        *,
        gateway: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        port_name: typing.Optional[builtins.str] = None,
        port_number: typing.Optional[jsii.Number] = None,
        vhost: typing.Optional["EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost"] = None,
    ) -> None:
        """Match on envoy HTTP route configuration attributes.

        :param gateway: 
        :param name: Route configuration name to match on.
        :param port_name: Applicable only for GATEWAY context.
        :param port_number: 
        :param vhost: 

        :schema: EnvoyFilterSpecConfigPatchesMatchRouteConfiguration
        """
        if isinstance(vhost, dict):
            vhost = EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost(**vhost)
        self._values: typing.Dict[str, typing.Any] = {}
        if gateway is not None:
            self._values["gateway"] = gateway
        if name is not None:
            self._values["name"] = name
        if port_name is not None:
            self._values["port_name"] = port_name
        if port_number is not None:
            self._values["port_number"] = port_number
        if vhost is not None:
            self._values["vhost"] = vhost

    @builtins.property
    def gateway(self) -> typing.Optional[builtins.str]:
        """
        :schema: EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#gateway
        """
        result = self._values.get("gateway")
        return result

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """Route configuration name to match on.

        :schema: EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#name
        """
        result = self._values.get("name")
        return result

    @builtins.property
    def port_name(self) -> typing.Optional[builtins.str]:
        """Applicable only for GATEWAY context.

        :schema: EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#portName
        """
        result = self._values.get("port_name")
        return result

    @builtins.property
    def port_number(self) -> typing.Optional[jsii.Number]:
        """
        :schema: EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#portNumber
        """
        result = self._values.get("port_number")
        return result

    @builtins.property
    def vhost(
        self,
    ) -> typing.Optional["EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost"]:
        """
        :schema: EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#vhost
        """
        result = self._values.get("vhost")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EnvoyFilterSpecConfigPatchesMatchRouteConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "route": "route"},
)
class EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        route: typing.Optional["EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute"] = None,
    ) -> None:
        """
        :param name: 
        :param route: Match a specific route within the virtual host.

        :schema: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost
        """
        if isinstance(route, dict):
            route = EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute(**route)
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if route is not None:
            self._values["route"] = route

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """
        :schema: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost#name
        """
        result = self._values.get("name")
        return result

    @builtins.property
    def route(
        self,
    ) -> typing.Optional["EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute"]:
        """Match a specific route within the virtual host.

        :schema: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost#route
        """
        result = self._values.get("route")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute",
    jsii_struct_bases=[],
    name_mapping={"action": "action", "name": "name"},
)
class EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute:
    def __init__(
        self,
        *,
        action: typing.Optional["EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction"] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        """Match a specific route within the virtual host.

        :param action: Match a route with specific action type.
        :param name: 

        :schema: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute
        """
        self._values: typing.Dict[str, typing.Any] = {}
        if action is not None:
            self._values["action"] = action
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def action(
        self,
    ) -> typing.Optional["EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction"]:
        """Match a route with specific action type.

        :schema: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute#action
        """
        result = self._values.get("action")
        return result

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """
        :schema: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute#name
        """
        result = self._values.get("name")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction"
)
class EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction(enum.Enum):
    """Match a route with specific action type.

    :schema: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction
    """

    ANY = "ANY"
    """ANY."""
    ROUTE = "ROUTE"
    """ROUTE."""
    REDIRECT = "REDIRECT"
    """REDIRECT."""
    DIRECT_RESPONSE = "DIRECT_RESPONSE"
    """DIRECT_RESPONSE."""


@jsii.data_type(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecConfigPatchesPatch",
    jsii_struct_bases=[],
    name_mapping={
        "filter_class": "filterClass",
        "operation": "operation",
        "value": "value",
    },
)
class EnvoyFilterSpecConfigPatchesPatch:
    def __init__(
        self,
        *,
        filter_class: typing.Optional["EnvoyFilterSpecConfigPatchesPatchFilterClass"] = None,
        operation: typing.Optional["EnvoyFilterSpecConfigPatchesPatchOperation"] = None,
        value: typing.Any = None,
    ) -> None:
        """The patch to apply along with the operation.

        :param filter_class: Determines the filter insertion order.
        :param operation: Determines how the patch should be applied.
        :param value: The JSON config of the object being patched.

        :schema: EnvoyFilterSpecConfigPatchesPatch
        """
        self._values: typing.Dict[str, typing.Any] = {}
        if filter_class is not None:
            self._values["filter_class"] = filter_class
        if operation is not None:
            self._values["operation"] = operation
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def filter_class(
        self,
    ) -> typing.Optional["EnvoyFilterSpecConfigPatchesPatchFilterClass"]:
        """Determines the filter insertion order.

        :schema: EnvoyFilterSpecConfigPatchesPatch#filterClass
        """
        result = self._values.get("filter_class")
        return result

    @builtins.property
    def operation(
        self,
    ) -> typing.Optional["EnvoyFilterSpecConfigPatchesPatchOperation"]:
        """Determines how the patch should be applied.

        :schema: EnvoyFilterSpecConfigPatchesPatch#operation
        """
        result = self._values.get("operation")
        return result

    @builtins.property
    def value(self) -> typing.Any:
        """The JSON config of the object being patched.

        :schema: EnvoyFilterSpecConfigPatchesPatch#value
        """
        result = self._values.get("value")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EnvoyFilterSpecConfigPatchesPatch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecConfigPatchesPatchFilterClass"
)
class EnvoyFilterSpecConfigPatchesPatchFilterClass(enum.Enum):
    """Determines the filter insertion order.

    :schema: EnvoyFilterSpecConfigPatchesPatchFilterClass
    """

    UNSPECIFIED = "UNSPECIFIED"
    """UNSPECIFIED."""
    AUTHN = "AUTHN"
    """AUTHN."""
    AUTHZ = "AUTHZ"
    """AUTHZ."""
    STATS = "STATS"
    """STATS."""


@jsii.enum(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecConfigPatchesPatchOperation"
)
class EnvoyFilterSpecConfigPatchesPatchOperation(enum.Enum):
    """Determines how the patch should be applied.

    :schema: EnvoyFilterSpecConfigPatchesPatchOperation
    """

    INVALID = "INVALID"
    """INVALID."""
    MERGE = "MERGE"
    """MERGE."""
    ADD = "ADD"
    """ADD."""
    REMOVE = "REMOVE"
    """REMOVE."""
    INSERT_BEFORE = "INSERT_BEFORE"
    """INSERT_BEFORE."""
    INSERT_AFTER = "INSERT_AFTER"
    """INSERT_AFTER."""
    INSERT_FIRST = "INSERT_FIRST"
    """INSERT_FIRST."""
    REPLACE = "REPLACE"
    """REPLACE."""


@jsii.data_type(
    jsii_type="networkingistioioenvoyfilter.EnvoyFilterSpecWorkloadSelector",
    jsii_struct_bases=[],
    name_mapping={"labels": "labels"},
)
class EnvoyFilterSpecWorkloadSelector:
    def __init__(
        self,
        *,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        """
        :param labels: 

        :schema: EnvoyFilterSpecWorkloadSelector
        """
        self._values: typing.Dict[str, typing.Any] = {}
        if labels is not None:
            self._values["labels"] = labels

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """
        :schema: EnvoyFilterSpecWorkloadSelector#labels
        """
        result = self._values.get("labels")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EnvoyFilterSpecWorkloadSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "EnvoyFilter",
    "EnvoyFilterOptions",
    "EnvoyFilterSpec",
    "EnvoyFilterSpecConfigPatches",
    "EnvoyFilterSpecConfigPatchesApplyTo",
    "EnvoyFilterSpecConfigPatchesMatch",
    "EnvoyFilterSpecConfigPatchesMatchCluster",
    "EnvoyFilterSpecConfigPatchesMatchContext",
    "EnvoyFilterSpecConfigPatchesMatchListener",
    "EnvoyFilterSpecConfigPatchesMatchListenerFilterChain",
    "EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter",
    "EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter",
    "EnvoyFilterSpecConfigPatchesMatchProxy",
    "EnvoyFilterSpecConfigPatchesMatchRouteConfiguration",
    "EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost",
    "EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute",
    "EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction",
    "EnvoyFilterSpecConfigPatchesPatch",
    "EnvoyFilterSpecConfigPatchesPatchFilterClass",
    "EnvoyFilterSpecConfigPatchesPatchOperation",
    "EnvoyFilterSpecWorkloadSelector",
]

publication.publish()
